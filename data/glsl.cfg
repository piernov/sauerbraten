// standard shader definitions

lazyshader = [
    defershader $arg1 $arg2 [
        shader @arg1 @arg2 [@@arg3] [@@arg4]
    ]
]

lmcoordscale = (divf 1 32767)

shader 0 "null" [
    void main(void)
    { 
        gl_Position = gl_Vertex;
    }
] [
    void main(void) 
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    }
]

///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

shader 0 "hud" [
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = color * texture2D(tex0, texcoord0);
    }
]

shader 0 "hudnotexture" [
    uniform mat4 hudmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * gl_Vertex;
        color = gl_Color;
    }
] [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]

shader 0 "hudrect" [
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = color * texture2DRect(tex0, texcoord0);
    }
]

shader 0 "hudrgb" [
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor.rgb = color.rgb * texture2D(tex0, texcoord0).rgb;
        gl_FragColor.a   = color.a;
    }
]

///////////////////////////////////////////////////
//
// miscellaneous default shaders
//
///////////////////////////////////////////////////

shader 0 "texture" [
    uniform mat4 camprojmatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = color * texture2D(tex0, texcoord0);
    }
]

shader 0 "notexture" [
    uniform mat4 camprojmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
    }
] [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]

shader 0 "cubemap" [
    varying vec3 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xyz;
        color = gl_Color;
    }
] [
    varying vec3 texcoord0;
    varying vec4 color;
    uniform samplerCube tex0;
    void main(void)
    {
        gl_FragColor = color * textureCube(tex0, texcoord0);
    }
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = color * texture2D(tex0, texcoord0);
    }
]

shader 0 "foggednotexture" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
    }
] [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]

shader 0 "fogoverlay" [
    varying vec4 color;
    void main(void)
    {
        gl_Position = gl_Vertex;
        color = gl_Color;
    }
] [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    uniform mat4 camprojmatrix;
    void main() { gl_Position = camprojmatrix * gl_Vertex; } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
    stype = 0
    if (>= (strstr $arg1 "env") 0) [stype = (+ $stype 2)]
    shader $stype $arg1 [
        #pragma CUBE2_fog
        #pragma CUBE2_water
        @(if (>= $numargs 5) [result $arg5])
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = camprojmatrix * gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy + texgenscroll;
            texcoord1 = gl_MultiTexCoord1.xy * @lmcoordscale;

            @arg2

            #pragma CUBE2_shadowmap
            #pragma CUBE2_dynlight
        }
    ] [
        @(if (>= $numargs 5) [result $arg5])
        @(if (>= $numargs 6) [result $arg6])
        uniform vec4 colorparams;
        varying vec2 texcoord0, texcoord1;
        uniform sampler2D diffusemap, lightmap;
        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, texcoord0);   
            vec4 lm = texture2D(lightmap, texcoord1);

            #pragma CUBE2_shadowmap lm
            #pragma CUBE2_dynlight lm

            @arg3

            diffuse *= colorparams;
            @(if (|| (< $numargs 4) [=s $arg4 []]) [result [gl_FragColor = diffuse * lm;]] [result $arg4])
        }
    ]
]

glareworldshader = [
    variantshader (if (< (strstr $arg1 "env") 0) 4 6) $arg1 4 [
        #pragma CUBE2_fog
        @(if (>= $numargs 4) [result $arg4])
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = camprojmatrix * gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy + texgenscroll;
            texcoord1 = gl_MultiTexCoord1.xy * @lmcoordscale;

            @arg2
        }
    ] [
        @(if (>= $numargs 4) [result $arg4])
        @(if (>= $numargs 5) [result $arg5])
        uniform vec4 colorparams;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            @arg3
        }
    ]
]

worldshader "stdworld" [] []

defershader 0 "decalworld" [
  worldshader "decalworld" [] [
    vec4 diffuse2 = texture2D(decal, texcoord0);
    diffuse.rgb = mix(diffuse.rgb, diffuse2.rgb, diffuse2.a);
  ] [] [] [uniform sampler2D decal;]
]

defershader 0 "glowworld" [
  defuniformparam "glowcolor" 1 1 1 // glow color
  worldshader "glowworld" [] [] [
    vec3 glow = texture2D(glowmap, texcoord0).rgb;
    glow *= glowcolor.rgb;
    gl_FragColor = diffuse*lm + vec4(glow, 0.0);
  ] [] [uniform sampler2D glowmap;]
  glareworldshader "glowworld" [] [
    vec3 glow = texture2D(glowmap, texcoord0).rgb;
    glow *= glowcolor.rgb;
    float k = max(glow.r, max(glow.g, glow.b)); 
    gl_FragColor.rgb = min(k*k*32.0, 1.0) * glow;
    #pragma CUBE2_variantoverride gl_FragColor.a = texture2D(lightmap, texcoord1).a;
    gl_FragColor.a = colorparams.a;
  ] [] [
    uniform sampler2D glowmap; 
    #pragma CUBE2_variant uniform sampler2D lightmap;
  ]
]

defershader 0 "pulseworld" [
  defuniformparam "pulsespeed" 1 // pulse frequency (Hz)
  worldshader "pulseworld" [
    pulse = abs(fract(millis * pulsespeed.x)*2.0 - 1.0); 
  ] [
    vec3 diffuse2 = texture2D(decal, texcoord0).rgb; 
    diffuse.rgb = mix(diffuse.rgb, diffuse2, pulse);
  ] [] [uniform float millis; varying float pulse;] [uniform sampler2D decal;]
]

defershader 0 "pulseglowworld" [
  defuniformparam "glowcolor" 1 1 1 // glow color
  defuniformparam "pulseglowspeed" 1 // pulse frequency (Hz)
  defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
  worldshader "pulseglowworld" [
    pulse = mix(glowcolor.rgb, pulseglowcolor.rgb, abs(fract(millis * pulseglowspeed.x)*2.0 - 1.0));
  ] [] [
    vec3 glow = texture2D(glowmap, texcoord0).rgb;
    gl_FragColor = diffuse*lm + vec4(glow*pulse, 0.0);
  ] [uniform float millis; varying vec3 pulse;] [uniform sampler2D glowmap;]
  glareworldshader "pulseglowworld" [
    pulse = mix(glowcolor.rgb, pulseglowcolor.rgb, abs(fract(millis * pulseglowspeed.x)*2.0 - 1.0));
  ] [
    vec3 glow = texture2D(glowmap, texcoord0).rgb;
    glow *= pulse;
    float k = max(glow.r, max(glow.g, glow.b)); 
    gl_FragColor.rgb = min(k*k*32.0, 1.0) * glow;
    #pragma CUBE2_variantoverride gl_FragColor.a = texture2D(lightmap, texcoord1).a;
    gl_FragColor.a = colorparams.a;
  ] [uniform float millis; varying vec3 pulse;] [
    uniform sampler2D glowmap; 
    #pragma CUBE2_variant uniform sampler2D lightmap;
  ]
]

shader 0 "fogworld" [
    #pragma CUBE2_water
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
    }
] [
    uniform vec3 fogcolor;
    void main(void)
    {
        gl_FragColor = vec4(fogcolor, 1.0);
    }
]

shader 0 "noglareworld" [
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
    }
] [
    void main(void)
    {
        gl_FragColor = vec4(0.0);
    }
]

shader 0 "noglareblendworld" [
    uniform mat4 camprojmatrix;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord1.xy * @lmcoordscale;
    }
] [
    varying vec2 texcoord0;
    uniform sampler2D lightmap;
    void main(void)
    {
        gl_FragColor.rgb = vec3(0.0);
        gl_FragColor.a = texture2D(lightmap, texcoord0).a;
    }
]

shader 0 "noglarealphaworld" [
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
    }
] [
    uniform vec4 colorparams;
    uniform sampler2D lightmap;
    void main(void)
    {
        gl_FragColor.rgb = vec3(0.0);
        gl_FragColor.a = colorparams.a;
    }
]
 
defershader 2 "envworld" [
  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworld" [
    normal = gl_Normal;
    camvec = camera - gl_Vertex.xyz; 
  ] [
    vec3 reflect = textureCube(envmap, 2.0*normal*dot(camvec, normal) - camvec).rgb;
  ] [
    diffuse *= lm;
    gl_FragColor.rgb = mix(diffuse.rgb, reflect, envscale.rgb);
    gl_FragColor.a = diffuse.a; 
  ] [uniform vec3 camera; varying vec3 normal, camvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldfast" [
    vec3 camvec = camera - gl_Vertex.xyz;
    rvec = 2.0*gl_Normal*dot(camvec, gl_Normal) - camvec;
  ] [
    vec3 reflect = textureCube(envmap, rvec).rgb;
  ] [
    diffuse *= lm;
    gl_FragColor.rgb = mix(diffuse.rgb, reflect, envscale.rgb);
    gl_FragColor.a = diffuse.a; 
  ] [uniform vec3 camera; varying vec3 rvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldalt" [] []

  altshader envworld envworldalt
  fastshader envworld envworldfast 2
  fastshader envworld envworldalt 1
]

shader 0 "depthfxworld" [
    uniform mat4 camprojmatrix;
    uniform vec4 depthscale, depthoffsets;
    varying vec4 depthranges;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        depthranges = depthoffsets + gl_Position.w*depthscale;
    }
] [
    varying vec4 depthranges;
    void main(void)
    {
        gl_FragColor = depthranges;
    }
]

shader 0 depthfxsplitworld [
    uniform mat4 camprojmatrix;
    uniform vec4 depthscale, depthoffsets;
    varying vec4 depthranges;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        depthranges = depthoffsets + gl_Position.w*depthscale;
    }
] [
    varying vec4 depthranges;
    void main(void)
    {
        vec4 ranges = vec4(depthranges.x, fract(depthranges.yzw));
        ranges.xy -= ranges.yz*vec2(0.00390625, 0.00390625);
        gl_FragColor = ranges;
    }
]

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (7 steps)
//    g -> glow
//    G -> pulse glow
//    i -> glare intensity

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    bumptype = $arg2
    stype = (? (btopt "e") 3 1)
    if (! (btopt "i")) [
        if (btopt "G") [
            defuniformparam "glowcolor" 1 1 1 // glow color
            defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
            defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
        ] [if (btopt "g") [
            defuniformparam "glowcolor" 1 1 1  // glow color
        ]]
        if (btopt "S") [
            defuniformparam "specscale" 6 6 6 // spec map multiplier
        ] [if (btopt "s") [
            defuniformparam "specscale" 1 1 1 // spec multiplier
        ]]
        if (|| (btopt "p") (btopt "P")) [
            defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
        ]
        if (btopt "R") [
            defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
        ] [if (btopt "r") [
            defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
        ]]
    ] [
        if (btopt "s") [stype = (+ $stype 8)]
    ]
    variantshader $stype $arg1 (? (btopt "i") 4 -1) [
        #pragma CUBE2_fog
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        varying vec2 texcoord0, texcoord1;
        @(if (|| (btopt "t") (btopt "r")) [result [uniform vec3 camera; varying vec3 camvec;]])
        @(if (btopt "G") [result [uniform float millis; varying float pulse;]])
        @(if (btopt "r") [result [varying mat3 world;]]) 
        void main(void)
        {
            gl_Position = camprojmatrix * gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy + texgenscroll;
            texcoord1 = gl_MultiTexCoord1.xy * @lmcoordscale;

            @(if (btopt "o") [result [
                vec4 tangent = gl_Color*2.0 - 1.0;
                vec3 bitangent = cross(gl_Normal, tangent.xyz) * tangent.w;
                @@(if (btopt "t") [result [
                    // trans eye vector into TS
                    vec3 camobj = camera - gl_Vertex.xyz;
                    camvec = vec3(dot(camobj, tangent.xyz), dot(camobj, bitangent), dot(camobj, gl_Normal));
                ]])
                @@(if (btopt "r") [result [
                    @@(if (! (btopt "t")) [result [
                        camvec = camera - gl_Vertex.xyz;
                    ]])
                    // calculate tangent -> world transform
                    world = mat3(tangent.xyz, bitangent, gl_Normal);
                ]])
            ]]) 
        
            @(if (btopt "G") [result [
                pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
            ]])

            @(if (|| (! (btopt "i")) (btopt "s")) [result [
                #pragma CUBE2_dynlight
            ]])
            @(if (! (btopt "i")) [result [
                #pragma CUBE2_shadowmap
                #pragma CUBE2_water
            ]])
        }
    ] [
        uniform vec4 colorparams;
        varying vec2 texcoord0, texcoord1;
        uniform sampler2D diffusemap, lmcolor, lmdir;
        @(if (|| (! (btopt "i")) (btopt "s") (btopt "p") (btopt "P")) [result [uniform sampler2D normalmap;]])
        @(if (|| (btopt "t") (btopt "r")) [result [varying vec3 camvec;]])
        @(if (btopt "g") [result [uniform sampler2D glowmap;]])
        @(if (btopt "G") [result [varying float pulse;]])
        @(if (btopt "r") [result [uniform samplerCube envmap; varying mat3 world;]])
        @(if (|| (! (btopt "i")) (btopt "s")) [result [uniform vec4 ambient;]])
        void main(void)
        {
            @(if (|| (! (btopt "i")) (btopt "s")) [result [
                vec4 lmc = texture2D(lmcolor, texcoord1);
                gl_FragColor.a = colorparams.a * lmc.a;
                vec3 lmlv = texture2D(lmdir, texcoord1).rgb*2.0 - 1.0;
            ]])
            @(if (btopt "t") [result [vec3 camdir = normalize(camvec);]])
            @(if (btopt "p") [result [
                float height = texture2D(normalmap, texcoord0).a;
                vec2 dtc = texcoord0 + camdir.xy*(height*parallaxscale.x + parallaxscale.y);
            ]])
            @(if (btopt "P") [result [
                const float step = -1.0/7.0;
                vec3 duv = vec3((step*parallaxscale.x/camdir.z)*camdir.xy, step);
                vec3 htc = vec3(texcoord0 + duv.xy*parallaxscale.y, 1.0);
                vec4 height = texture2D(normalmap, htc.xy);
                @@(loopconcat i 7 [concatword [
                    htc += height.w < htc.z ? duv : vec3(0.0);
                    height = texture2D(normalmap, htc.xy);
                ]])
                #define dtc htc.xy
                #define bump height.xyz    
            ]])
            @(if (|| (btopt "p") (btopt "P")) [] [result [#define dtc texcoord0]])

            @(if (|| (! (btopt "i")) (btopt "S")) [result [
                vec4 diffuse = texture2D(diffusemap, dtc);
            ]])
            @(if (! (btopt "i")) [result [
                diffuse.rgb *= colorparams.rgb;
            ]])

            @(if (|| (! (btopt "i")) (btopt "s")) [result [
                @(if (! (btopt "P")) [result [vec3 bump = texture2D(normalmap, dtc).rgb;]])
                bump = bump*2.0 - 1.0;
            ]])

            @(if (btopt "s") [result [
                vec3 halfangle = normalize(camdir + lmlv);
                float spec = pow(clamp(dot(halfangle, bump), 0.0, 1.0), @(? (btopt "i") "128.0" "32.0"));
                @(if (btopt "i") [result [spec = min(spec*64.0, 1.0);]]) 
                @(if (btopt "S") [result [spec *= diffuse.a;]])
                @(if (btopt "i") [result [
                    @(? (btopt "S") "diffuse.rgb" "vec3 diffuse") = specscale.xyz*spec;
                ]] [result [
                    diffuse.rgb += specscale.xyz*spec;
                ]])
            ]])

            @(if (|| (! (btopt "i")) (btopt "s")) [result [
                lmc.rgb = max(lmc.rgb*clamp(dot(lmlv, bump), 0.0, 1.0), ambient.xyz);
                @(if (btopt "i") [result [
                    #pragma CUBE2_dynlight lmc

                    @(? (btopt "g") "diffuse.rgb" "gl_FragColor.rgb") = diffuse.rgb * lmc.rgb;
                ]] [result [
                    #pragma CUBE2_shadowmap lmc
                    #pragma CUBE2_dynlight lmc

                    @(? (|| (btopt "g") (btopt "r")) "diffuse.rgb" "gl_FragColor.rgb") = diffuse.rgb * lmc.rgb;
                ]])
            ]])
               
            @(if (btopt "r") [result [
                vec3 rvec;
                @(if (btopt "t") [result [
                    vec3 rvects = 2.0*bump*dot(camvec, bump) - camvec;
                    rvec = world * rvects;
                ]] [result [
                    vec3 bumpw = world * bump;
                    rvec = 2.0*bumpw*dot(camvec, bumpw) - camvec;
                ]])
                vec3 reflect = textureCube(envmap, rvec).rgb;
                @@(if (btopt "R") [result [
                    vec3 rmod = envscale.xyz*diffuse.a;
                ]] [result [
                    #define rmod envscale.xyz
                ]])
                @(? (btopt "g") "diffuse.rgb" "gl_FragColor.rgb") = mix(diffuse.rgb, reflect, rmod);
            ]])

            @(if (btopt "g") [result [
                vec3 glow = texture2D(glowmap, dtc).rgb;
                @@(if (btopt "G") [result [
                    vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                ]])
                @@(if (btopt "i") [result [
                    glow *= @(? (btopt "G") "pulsecol" "glowcolor.xyz");
                    float k = max(glow.r, max(glow.g, glow.b));
                    k = min(k*k*32.0, 1.0);
                    @(if (btopt "s") [result [
                        gl_FragColor.rgb = glow*k + diffuse.rgb;
                    ]] [result [
                        gl_FragColor.rgb = glow*k;
                        #pragma CUBE2_variantoverride gl_FragColor.a = texture2D(lmcolor, texcoord1).a;
                        gl_FragColor.a = colorparams.a;
                    ]])
                ]] [result [
                    gl_FragColor.rgb = glow * @(? (btopt "G") "pulsecol" "glowcolor.xyz") + diffuse.rgb;
                ]])
            ]])
        }
    ]
]

bumpshader = [
    defershader (? (>= (strstr $arg2 "e") 0) 3 1) $arg1 [
        bumpvariantshader @arg1 @arg2
        if (|| (btopt "g") (btopt "s")) [
            bumpvariantshader @@arg1 (strreplace (concatword @@arg2 "i") "r")
        ]
    ]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "otsg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "otsSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "otsgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "otsSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "pot"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "pots"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "potsS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "potsg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "eor"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "eorg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epotr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "epotrg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

// skeletal animation for matrices and dual quaternions

skelanimdefs = [
    skelanimlength = (min (- $maxvsuniforms (+ $reservevpparams 10)) $maxskelanimdata)
    result [
        #pragma CUBE2_attrib vweights 6
        #pragma CUBE2_attrib vbones 7
        attribute vec4 vweights; 
        attribute vec4 vbones;
        #pragma CUBE2_uniform animdata
        uniform vec4 animdata[@@skelanimlength];
    ]
]

skelanim = [
    result [
        int index = int(vbones.x);
        @(if (= $arg1 1) [result [
            vec4 dqreal = animdata[index];
            vec4 dqdual = animdata[index+1];
        ]] [result [
            vec4 dqreal = animdata[index] * vweights.x;
            vec4 dqdual = animdata[index+1] * vweights.x;
            index = int(vbones.y);
            dqreal += animdata[index] * vweights.y;
            dqdual += animdata[index+1] * vweights.y;
            @(if (>= $arg1 3) [result [
                index = int(vbones.z);
                dqreal += animdata[index] * vweights.z;
                dqdual += animdata[index+1] * vweights.z;
            ]])
            @(if (>= $arg1 4) [result [
                index = int(vbones.w);
                dqreal += animdata[index] * vweights.w;
                dqdual += animdata[index+1] * vweights.w;
            ]])
            float len = length(dqreal);
            dqreal /= len;
            dqdual /= len;
        ]])

        vec4 opos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, gl_Vertex.xyz) + gl_Vertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + gl_Vertex.xyz, gl_Vertex.w);

        @(if $arg2 [result [
            vec3 onormal = cross(dqreal.xyz, cross(dqreal.xyz, gl_Normal) + gl_Normal*dqreal.w)*2.0 + gl_Normal;
        ]])

        @(if $arg3 [result [
            vec3 otangent = cross(dqreal.xyz, cross(dqreal.xyz, vtangent.xyz) + vtangent.xyz*dqreal.w)*2.0 + vtangent.xyz;
        ]])
    ]
]

// model shadowmapping

shadowmapcastervertexshader = [
    result [
        @(if (>= $numargs 2) [result $arg1])
        uniform mat4 modelmatrix;
        uniform vec4 shadowintensity;
        varying vec4 shadowmapvals;
        void main(void)
        {
            @(if (>= $numargs 2) [result $arg2] [result [
                #define opos gl_Vertex
            ]])
            gl_Position = modelmatrix * opos;
            shadowmapvals = vec4(1.0 - gl_Position.z, 1.0, 0.0, shadowintensity.x);
        }
    ]
]

shader 0 shadowmapcaster (shadowmapcastervertexshader) [
    varying vec4 shadowmapvals;
    void main(void)
    {
        gl_FragColor = shadowmapvals;
    }
]
loop i 4 [
    variantshader 0 shadowmapcaster 0 (shadowmapcastervertexshader (skelanimdefs (+ $i 1) 0 0) (skelanim (+ $i 1) 0 0)) []
]

shader 0 "shadowmapreceiver" [
    uniform mat4 shadowmatrix;
    uniform vec2 shadowmapbias;
    varying vec4 shadowmapvals;
    void main(void)
    {
        gl_Position = shadowmatrix * gl_Vertex;
        shadowmapvals = vec4(0.0, 0.0, shadowmapbias.y - gl_Position.z, 0.0); 
    }
] [
    varying vec4 shadowmapvals;
    void main(void)
    {
        gl_FragColor = shadowmapvals;
    }
]

// model stenciling

notexturemodelvertexshader = [
    result [
        uniform mat4 modelmatrix;
        varying vec4 color;
        @(if (>= $numargs 2) [result $arg1])
        #pragma CUBE2_fog
        void main(void)
        {
            @(if (>= $numargs 2) [result $arg2] [result [
                #define opos gl_Vertex
            ]])
            gl_Position = modelmatrix * opos;
            color = gl_Color;
        }
    ]
]

shader 0 notexturemodel (notexturemodelvertexshader) [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]
loop i 4 [
    variantshader 0 notexturemodel 0 (notexturemodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelanim (+ $i 1) 0 0)) []
]

// mdltype:
//    e -> envmap
//    n -> normalmap
//    s -> spec
//    m -> masks
//    b -> dual-quat skeletal animation
//    a -> alpha-tested
//    i -> glare intensity

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

modelvertexshader = [
    modeltype = $arg1
    result [
        @(if (mdlopt "b") [skelanimdefs $arg2 1 (mdlopt "n")])
        #pragma CUBE2_fog
        @(if (mdlopt "n") [result [
            #pragma CUBE2_attrib vtangent 1
            attribute vec4 vtangent;
        ]])
        uniform mat4 modelmatrix; 
        uniform vec3 modelcamera, lightdir, lightscale;
        uniform vec2 texscroll;
        varying vec2 texcoord0;
        varying vec4 color;
        @(if (mdlopt "n") [result [
            @(if (mdlopt "e") [result [
                uniform mat3 modelworld;
                varying vec3 camvec;
                varying mat3 world;
            ]] [result [
                varying vec3 lightvec, halfangle;
            ]])
        ]] [result [
            @(if (mdlopt "s") [result [
                varying vec3 nvec, halfangle;
            ]])
            @(if (mdlopt "e") [result [
                uniform mat3 modelworld;
                uniform vec2 envmapscale;
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        void main(void)
        {
            @(if (mdlopt "b") [result [
                @(skelanim $arg2 1 (mdlopt "n"))
            ]] [result [
                #define opos gl_Vertex
                #define onormal gl_Normal
                #define otangent vtangent.xyz
            ]])

            gl_Position = modelmatrix * opos;

            @(if (|| (mdlopt "n") (mdlopt "s") (mdlopt "i")) [result [
                color = gl_Color;
            ]])
            texcoord0 = gl_MultiTexCoord0.xy + texscroll;
      
            @(if (|| (mdlopt "e") (mdlopt "s")) [result [
                vec3 camdir = normalize(modelcamera - opos.xyz);
            ]])

            @(if (mdlopt "n") [
                if (mdlopt "e") [result [
                    camvec = modelworld * camdir;
                    // composition of tangent -> object and object -> world transforms
                    //   becomes tangent -> world
                    vec3 wnormal = modelworld * onormal;
                    vec3 wtangent = modelworld * otangent;
                    world = mat3(wtangent, cross(wnormal, wtangent) * vtangent.w, wnormal);
                ]] [result [
                    vec3 obitangent = cross(onormal, otangent) * vtangent.w;
                    lightvec = vec3(dot(lightdir, otangent), dot(lightdir, obitangent), dot(lightdir, onormal));
                    @(if (mdlopt "s") [result [
                        vec3 halfdir = lightdir + camdir; 
                        halfangle = vec3(dot(halfdir, otangent), dot(halfdir, obitangent), dot(halfdir, onormal));
                    ]])
                ]]
            ] [result [
                @(if (mdlopt "s") [result [
                    nvec = onormal; 
                    halfangle = lightdir + camdir;
                ]] [if (! (mdlopt "i")) [result [
                    float intensity = dot(onormal, lightdir);
                    color = vec4(gl_Color.rgb*clamp(intensity*(intensity*lightscale.x + lightscale.y) + lightscale.z, 0.0, 1.0), gl_Color.a);
                ]]])
                @(if (mdlopt "e") [result [
                    float invfresnel = dot(camdir, onormal);
                    rvec = modelworld * (2.0*invfresnel*onormal - camdir);
                    rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;    
                ]])
            ]])
        }
    ] 
]

modelfragmentshader = [
    modeltype = $arg1
    result [
        varying vec2 texcoord0;
        varying vec4 color;
        @(if (mdlopt "n") [result [
            @(if (mdlopt "e") [result [
                #define lightvec lightdirworld
                uniform vec3 lightdirworld;
                uniform vec2 envmapscale;
                varying vec3 camvec;
                varying mat3 world;
            ]] [result [
                varying vec3 lightvec, halfangle;
            ]])
        ]] [result [
            @(if (mdlopt "s") [result [
                #define lightvec lightdir
                uniform vec3 lightdir;
                varying vec3 nvec, halfangle;
            ]])
            @(if (mdlopt "e") [result [
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        @(if (&& (|| (mdlopt "s") (mdlopt "n")) (! (mdlopt "i"))) [result [uniform vec3 lightscale;]])
        @(if (|| (mdlopt "s") (mdlopt "m")) [result [uniform vec4 maskscale;]])
        uniform sampler2D tex0;
        @(if (mdlopt "m") [result [uniform sampler2D tex1;]])
        @(if (mdlopt "e") [result [uniform samplerCube tex2;]])
        @(if (mdlopt "n") [result [uniform sampler2D tex3;]])
        @(? (mdlopt "a") [uniform float alphatest;])
        void main(void)
        {
            vec4 light = texture2D(tex0, texcoord0);

            @(? (mdlopt "a") [
                if(light.a <= alphatest)
                    discard;
            ])

            light.rgb *= 2.0;

            @(if (mdlopt "m") [result [
                vec3 masks = texture2D(tex1, texcoord0).rgb;
                vec3 glow = light.rgb * maskscale.y;
            ]])

            @(if (mdlopt "n") [result [
                vec3 normal = texture2D(tex3, texcoord0).rgb - 0.5;
                @(if (mdlopt "e") [result [
                    normal = world * normal;
                ]])
                normal = normalize(normal);
            ]])

            @(if (mdlopt "s") [result [
                @(if (mdlopt "n") [
                    if (mdlopt "e") [result [
                        vec3 halfangle = lightvec + camvec;
                    ]]
                ] [result [
                    vec3 normal = normalize(nvec);
                ]])
                float spec = maskscale.x * pow(clamp(dot(normalize(halfangle), normal), 0.0, 1.0), @(? (mdlopt "i") "256.0" "128.0"));
                @(if (mdlopt "m") [result [spec *= masks.r;]])   // specmap in red channel
            ]])

            @(if (mdlopt "i") [
                if (mdlopt "s") [result [
                    spec *= maskscale.z;
                    @(? (mdlopt "m") "light.rgb" "gl_FragColor.rgb") = spec * color.rgb;
                ]] [
                    if (! (mdlopt "m")) [result [gl_FragColor.rgb = vec3(0.0);]]
                ]
            ] [result [
                @(if (|| (mdlopt "s") (mdlopt "n")) [result [
                    float intensity = dot(normal, lightvec);
                    light.rgb *= clamp(intensity*(intensity*lightscale.x + lightscale.y) + lightscale.z, 0.0, 1.0);
                ]])
                @(if (mdlopt "s") [result [
                    light.rgb += spec;
                ]])
                @(if (|| (mdlopt "m") (mdlopt "e")) [result [
                    light.rgb *= color.rgb;
                ]] [result [
                    gl_FragColor = light * color;
                ]])
            ]])

            @(if (mdlopt "e") [result [
                @(if (mdlopt "n") [result [
                    vec3 camn = normalize(camvec);
                    float invfresnel = dot(camn, normal);
                    vec3 rvec = 2.0*invfresnel*normal - camn;
                    float rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;
                ]])
                vec3 reflect = textureCube(tex2, rvec).rgb;
                @(if (! (mdlopt "m")) [result [
                    gl_FragColor.rgb = mix(light.rgb, reflect, rmod);
                ]])
            ]])

            @(if (mdlopt "m") [result [
                @(if (mdlopt "e") [result [
                    light.rgb = mix(light.rgb, glow, masks.g); // glow mask in green channel
                    gl_FragColor.rgb = mix(light.rgb, reflect, rmod*masks.b); // envmap mask in blue channel
                ]] [if (mdlopt "i") [result [
                    float k = min(masks.g*masks.g*maskscale.w, 1.0); // glow mask in green channel
                    gl_FragColor.rgb = @(? (mdlopt "s") "glow*k + light.rgb" "glow*k");
                ]] [result [
                    gl_FragColor.rgb = mix(light.rgb, glow, masks.g); // glow mask in green channel
                ]]])
            ]])

            @(if (|| (mdlopt "i") (mdlopt "m") (mdlopt "e")) [result [
                gl_FragColor.a = light.a * color.a;
            ]])
        }
    ]
]

modelshader = [
    local shadername
    shadername = (concatword model $arg1)
    if (! (isshaderdefined $shadername)) [
        shader 0 $shadername (modelvertexshader $arg1) (modelfragmentshader $arg1)
        loop i 4 [
            variantshader 0 $shadername 0 (modelvertexshader (concatword $arg1 "b") (+ $i 1)) []
        ]
        glaremodeltype = (strreplace (concatword $arg1 "i") "e")
        if (< (strstr $glaremodeltype "s") 0) [glaremodeltype = (strreplace $glaremodeltype "n")]
        variantshader 0 $shadername 1 (modelvertexshader $glaremodeltype) (modelfragmentshader $glaremodeltype)
        loop i 4 [
            variantshader 0 $shadername 1 (modelvertexshader (concatword $glaremodeltype "b") (+ $i 1)) 1
        ]
        if (>= (strstr $arg1 "e") 0) [
            altshader $shadername (modelshader (strreplace $arg1 "e"))
        ]
        if (>= (strstr $arg1 "s") 0) [
            fastshader $shadername (modelshader (strreplace $arg1 "s")) 1
        ]
    ]
    result $shadername
]

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
    shader 0 $arg1 [
        uniform float offsets[8];
        varying vec2 texcoord0, texcoordp1, texcoordn1;
        @(loopconcat i (min (- $arg2 1) 2) [result [
            varying vec2 texcoordp@(+ $i 2), texcoordn@(+ $i 2);
        ]])
        void main(void)
        {
            gl_Position = gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy;
            vec2 tcp = gl_MultiTexCoord0.xy, tcn = gl_MultiTexCoord0.xy;
            tcp.@arg3 += offsets[1];
            tcn.@arg3 -= offsets[1];
            texcoordp1 = tcp;
            texcoordn1 = tcn;
            @(loopconcat i (min (- $arg2 1) 2) [result [
                tcp.@arg3 = gl_MultiTexCoord0.@arg3 + offsets[@@(+ $i 2)];
                tcn.@arg3 = gl_MultiTexCoord0.@arg3 - offsets[@@(+ $i 2)];
                texcoordp@(+ $i 2) = tcp;
                texcoordn@(+ $i 2) = tcn;
            ]])
        } 
    ] [
        uniform float weights[8];
        uniform float offsets[8];
        varying vec2 texcoord0, texcoordp1, texcoordn1;
        @(loopconcat i (min (- $arg2 1) 2) [result [
            varying vec2 texcoordp@(+ $i 2), texcoordn@(+ $i 2);
        ]])
        uniform sampler@[arg4] tex0;
        void main(void)
        {
            #define texval(coords) texture@[arg4](tex0, (coords))
            vec4 val = texval(texcoord0) * weights[0];
            @(loopconcat i $arg2 [
                if (< $i 3) [result [
                    val += weights[@@(+ $i 1)] * (texval(texcoordp@(+ $i 1)) + texval(texcoordn@(+ $i 1)));
                ]] [result [
                    val += weights[@@(+ $i 1)] *
                    @(if (=s $arg3 "x") [result [
                        (texval(vec2(texcoord0.x + offsets[@@(+ $i 1)], texcoord0.y)) +
                         texval(vec2(texcoord0.x - offsets[@@(+ $i 1)], texcoord0.y)));
                    ]] [result [
                        (texval(vec2(texcoord0.x, texcoord0.y + offsets[@@(+ $i 1)])) +
                         texval(vec2(texcoord0.x, texcoord0.y - offsets[@@(+ $i 1)])));
                    ]])
                ]]
            ])
            gl_FragColor = val;
        }
    ]
]

loop i 7 [
    blurshader (format "blurx%1" (+ $i 1)) (+ $i 1) x 2D
    blurshader (format "blury%1" (+ $i 1)) (+ $i 1) y 2D
    if (> $i 0) [
        altshader (format "blurx%1" (+ $i 1)) (format "blurx%1" $i)
        altshader (format "blury%1" (+ $i 1)) (format "blury%1" $i)
    ]
    blurshader (format "blurx%1rect" (+ $i 1)) (+ $i 1) x 2DRect
    blurshader (format "blury%1rect" (+ $i 1)) (+ $i 1) y 2DRect
    if (> $i 0) [
        altshader (format "blurx%1rect" (+ $i 1)) (format "blurx%1rect" $i)
        altshader (format "blury%1rect" (+ $i 1)) (format "blury%1rect" $i)
    ]
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [result [
    varying vec2 texcoord0;
    @arg2
    void main(void)
    {
        gl_Position = gl_Vertex;   // woohoo, no mvp :) 
        texcoord0 = gl_MultiTexCoord0.xy; 
        @arg1
    }
]]

fsps = [result [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    @arg2
    void main(void)
    {
        vec4 color = texture2DRect(tex0, texcoord0);
        @arg1
    }
]]

fsvs4 = [
    fsvs [
        texcoord1 = gl_MultiTexCoord0.xy + vec2(-1.5, -1.5);
        texcoord2 = gl_MultiTexCoord0.xy + vec2( 1.5, -1.5);
        texcoord3 = gl_MultiTexCoord0.xy + vec2(-1.5,  1.5);
        texcoord4 = gl_MultiTexCoord0.xy + vec2( 1.5,  1.5);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

fsps4 = [
    fsps [
        vec4 s00 = texture2DRect(tex0, texcoord1);
        vec4 s02 = texture2DRect(tex0, texcoord2);
        vec4 s20 = texture2DRect(tex0, texcoord3);
        vec4 s22 = texture2DRect(tex0, texcoord4);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" (fsvs) (fsps [gl_FragColor = 1.0 - color;])
lazyshader 0 "gbr"    (fsvs) (fsps [gl_FragColor = color.yzxw;])
lazyshader 0 "bw"     (fsvs) (fsps [gl_FragColor = vec4(dot(color.xyz, vec3(0.333)));])

// sobel

lazyshader 0 "sobel" (fsvs4) (fsps4 [
    vec4 t = s00 + s20 - s02 - s22;
    vec4 u = s00 + s02 - s20 - s22;
    gl_FragColor = color + t*t + u*u;
])

// rotoscope

lazyshader 0 "rotoscope" [
    uniform vec4 params;
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    void main(void)
    {
        gl_Position = gl_Vertex;
        t11 = gl_MultiTexCoord0.xy;
        t00 = vec2(-1.0, -1.0)*params.x + gl_MultiTexCoord0.xy;
        t12 = vec2( 0.0,  1.0)*params.x + gl_MultiTexCoord0.xy;
        t01 = vec2(-1.0,  0.0)*params.x + gl_MultiTexCoord0.xy;
        t20 = vec2( 1.0, -1.0)*params.x + gl_MultiTexCoord0.xy;
        t02 = vec2(-1.0,  1.0)*params.x + gl_MultiTexCoord0.xy;
        t21 = vec2( 1.0,  0.0)*params.x + gl_MultiTexCoord0.xy;
        t10 = vec2( 0.0, -1.0)*params.x + gl_MultiTexCoord0.xy;
        t22 = vec2( 1.0,  1.0)*params.x + gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    void main(void)
    {
        vec4 c00 = texture2DRect(tex0, t00);
        vec4 c01 = texture2DRect(tex0, t01);
        vec4 c02 = texture2DRect(tex0, t02);
        vec4 c10 = texture2DRect(tex0, t10);
        vec4 c11 = texture2DRect(tex0, t11);
        vec4 c12 = texture2DRect(tex0, t12);
        vec4 c20 = texture2DRect(tex0, t20);
        vec4 c21 = texture2DRect(tex0, t21);
        vec4 c22 = texture2DRect(tex0, t22);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 

        gl_FragColor = c11 * max(cc.z, sobel);
    }
]

blur3shader = [
    lazyshader 0 $arg1 [ 
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy + vec2(@(if $arg2 -0.5 0.0), @(if $arg3 -0.5 0.0));
            texcoord1 = gl_MultiTexCoord0.xy + vec2(@(if $arg2  0.5 0.0), @(if $arg3  0.5 0.0));
        }
    ] [
        varying vec2 texcoord0, texcoord1;
        uniform sampler2DRect tex0; 
        void main(void)
        {
            gl_FragColor = 0.5*(texture2DRect(tex0, texcoord0) + texture2DRect(tex0, texcoord1));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [
        varying vec2 texcoord0, texcoord1, texcoord2;
        void main(void)
        {
            gl_Position = gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy;
            texcoord1 = gl_MultiTexCoord0.xy + vec2(@(? $arg2 -1.333 0.0), @(? $arg3 -1.333 0.0));
            texcoord2 = gl_MultiTexCoord0.xy + vec2(@(? $arg2  1.333 0.0), @(? $arg3  1.333 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1, texcoord2;
        void main(void)
        {
            gl_FragColor = 0.4*texture2DRect(tex0, texcoord0) + 0.3*(texture2DRect(tex0, texcoord1) + texture2DRect(tex0, texcoord2));
        } 
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
    if (>= $numargs 2) [
        if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
        if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
    ]
]

shader 0 "screenrect" [
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = color * texture2DRect(tex0, texcoord0);
    }
]

// bloom-ish

shader 0 "glare" [
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    uniform float glarescale;
    varying vec2 texcoord0;
    uniform sampler2D tex0; 
    void main(void)
    {
        gl_FragColor = texture2D(tex0, texcoord0) * glarescale;
    }
]

lazyshader 0 "bloom_scale" (fsvs4) (fsps4 [
    gl_FragColor = 0.2 * (s02 + s00 + s22 + s20 + color);
])

lazyshader 0 "bloom_init" (fsvs) (fsps [
    float t = max(color.r, max(color.g, color.b));
    gl_FragColor = t*t*color;
])

bloomshader = [
  defershader 0 $arg1 [
    forceshader "bloom_scale"
    forceshader "bloom_init"
    shader 0 @arg1 [
        varying vec2 texcoord0;
        @@(loopconcat i $arg2 [result [
            varying vec2 texcoord@(+ $i 1);
        ]])
        void main(void)
        {
            gl_Position = gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy;
            vec2 tc = gl_MultiTexCoord0.xy;
            @@(loopconcat i $arg2 [concat [
                tc *= 0.5;
                texcoord@(+ $i 1) = tc;
            ]])
        }
    ] [
        uniform vec4 params;
        varying vec2 texcoord0;
        @@(loopconcat i $arg2 [result [
            varying vec2 texcoord@(+ $i 1);
        ]])
        uniform sampler2DRect tex0 @@(loopconcat i $arg2 [format ", tex%1" (+ $i 1)]); 
        void main(void)
        {
            vec4 sample = texture2DRect(tex0, texcoord0);
            @@(loopconcat i $arg2 [
                format [
                    @(? (> $i 0) "bloom +=" "vec4 bloom =") texture2DRect(tex%1, texcoord%1);
                ] (+ $i 1)
            ])
            gl_FragColor = bloom*params.x + sample;
        }
    ]
  ]
]

bloomshader bloom1 1
bloomshader bloom2 2
bloomshader bloom3 3
bloomshader bloom4 4
bloomshader bloom5 5
bloomshader bloom6 6

setupbloom = [
    addpostfx bloom_init 1 1 "+0"
    loop i (- $arg1 1) [
        addpostfx bloom_scale (+ $i 2) (+ $i 2) (concatword "+" (+ $i 1))
    ]
    addpostfx (concatword bloom $arg1) 0 0 (loopconcat i (+ $arg1 1) [result $i]) $arg2
]

bloom = [
    clearpostfx
    if (>= $numargs 1) [setupbloom 6 $arg1]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords 
// and blends the edge color
// and modulates the texture
explosionshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        uniform mat4 explosionmatrix;
        uniform vec3 center;
        uniform float millis;
        uniform vec3 texgenS, texgenT;
        varying vec4 color;
        varying vec2 texcoord0, texcoord1, texcoord2;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; uniform vec2 depthfxview; varying vec4 texcoord3; ]])
        void main(void)
        {
            vec4 wobble = vec4(gl_Vertex.xyz*(1.0 + 0.5*abs(fract(dot(gl_Vertex.xyz, center) + millis*2.0) - 0.5)), gl_Vertex.w);
            @(if (>= (strstr $arg1 "soft") 0) [result [
                gl_Position = explosionmatrix * wobble;

                texcoord3 = vec4((gl_Position.xy + gl_Position.w)*depthfxview, gl_Position.w, depthfxparams.y + gl_Position.w*depthfxparams.x);
            ]] [result [
                gl_Position = explosionmatrix * wobble;
            ]])

            color = gl_Color;
       
            texcoord0 = gl_MultiTexCoord0.xy;
            vec2 texgen = vec2(dot(texgenS, gl_Vertex.xyz), dot(texgenT, gl_Vertex.xyz));
            texcoord1 = texgen;
            texcoord2 = texgen - millis*0.5;
        } 
    ] [ 
        @(if (>= (strstr $arg1 "soft") 0) [result [
            uniform sampler2DRect tex2;
        ]])
        uniform sampler2D tex0, tex1;
        uniform vec2 blendparams;
        varying vec4 color;
        varying vec2 texcoord0, texcoord1, texcoord2;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; varying vec4 texcoord3; ]]) 
        @(if (>= (strstr $arg1 "soft8") 0) [result [uniform vec4 depthfxselect;]])
        void main(void)
        {
            vec2 dtc = texcoord0 + texture2D(tex0, texcoord2).xy*0.1; // use color texture as noise to distort texcoords
            vec4 diffuse = texture2D(tex0, dtc);
            float blend = max(pow(clamp(1.0 - dot(texcoord1, texcoord1), 0.0, 1.0), blendparams.x), blendparams.y);
            @(if (>= (strstr $arg1 "glare") 0) [result [
                float k = blend*blend;
                diffuse.rgb *= k*8.0;
                diffuse.a *= k;
                diffuse.b += k*k;
            ]] [result [
                diffuse *= blend*4.0; // dup alpha into RGB channels + intensify and over saturate
                diffuse.b += 0.5 - blend*0.5; // blue tint 
            ]])

            @(if (>= (strstr $arg1 "soft") 0) [result [
                gl_FragColor.rgb = diffuse.rgb * color.rgb;

                #define depthvals texture2DRectProj(tex2, texcoord3.xyz)
                @(if (>= (strstr $arg1 "soft8") 0) [result [
                    float depth = dot(depthvals, depthfxselect);
                ]] [result [
                    float depth = depthvals.x*depthfxparams.z;
                ]])
                gl_FragColor.a = diffuse.a * max(clamp(depth - texcoord3.w, 0.0, 1.0) * color.a, depthfxparams.w);
            ]] [result [
                gl_FragColor = diffuse * color;
            ]])
        }
    ]
]

looplist i ["" "glare" "soft" "soft8"] [
    explosionshader [explosion@i]
]

shader 0 "particlenotexture" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    uniform vec4 colorscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color * colorscale;
    } 
] [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]

particleshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        uniform mat4 camprojmatrix;
        uniform vec4 colorscale;
        varying vec2 texcoord0;
        varying vec4 color;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; uniform vec2 depthfxview; varying vec3 texcoord1, surface; ]]) 
        void main(void)
        {
            gl_Position = camprojmatrix * gl_Vertex;
            texcoord0 = gl_MultiTexCoord0.xy;
            color = gl_Color * colorscale; 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                texcoord1 = vec3((gl_Position.xy + gl_Position.w) * depthfxview, gl_Position.w);

                vec2 offset = gl_MultiTexCoord0.xy*2.82842712474619 - 1.4142135623731;
                surface = vec3(offset, depthfxparams.y + gl_Position.w*depthfxparams.x);
            ]])
        }
    ] [
        @(if (>= (strstr $arg1 "soft") 0) [result [
            uniform sampler2DRect tex2;
        ]])
        uniform sampler2D tex0;
        varying vec2 texcoord0;
        varying vec4 color;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; varying vec3 texcoord1, surface;]]) 
        @(if (>= (strstr $arg1 "soft8") 0) [result [uniform vec4 depthfxselect;]])
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);

            @(if (>= (strstr $arg1 "soft") 0) [result [
                #define depthvals texture2DRectProj(tex2, texcoord1)
                @(if (>= (strstr $arg1 "soft8") 0) [result [
                    float depth = dot(depthvals, depthfxselect);
                ]] [result [
                    float depth = depthvals.x*depthfxparams.z;
                ]])
                diffuse.a *= clamp(depth - dot(surface.xy, surface.xy) - surface.z, 0.0, 1.0);
            ]])

            gl_FragColor = diffuse * color;
        }
    ]     
]

looplist i ["" "soft" "soft8"] [
    particleshader [particle@i]
]

shader 0 "blendbrush" [
    uniform mat4 camprojmatrix;
    uniform vec4 texgenS, texgenT;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = vec2(dot(texgenS, gl_Vertex), dot(texgenT, gl_Vertex));
    }
] [
    varying vec4 color;
    varying vec2 texcoord0;
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = texture2D(tex0, texcoord0) * color;
    }
]

lazyshader 0 "moviergb" [
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    varying vec2 texcoord0;
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = texture2DRect(tex0, texcoord0);
    }
]

lazyshader 0 "movieyuv" [
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    varying vec2 texcoord0;
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample = texture2DRect(tex0, texcoord0).rgb;
        gl_FragColor = vec4(dot(sample, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample, vec3(-0.148224, -0.290992, 0.439216)) + 0.501961,
                            dot(sample, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            0.0);
    }
]

lazyshader 0 "moviey" [
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy + vec2(-1.5, 0.0);
        texcoord1 = gl_MultiTexCoord0.xy + vec2(-0.5, 0.0);
        texcoord2 = gl_MultiTexCoord0.xy + vec2( 0.5, 0.0);
        texcoord3 = gl_MultiTexCoord0.xy + vec2( 1.5, 0.0);
    }
] [
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, texcoord0).rgb;
        vec3 sample2 = texture2DRect(tex0, texcoord1).rgb;
        vec3 sample3 = texture2DRect(tex0, texcoord2).rgb;
        vec3 sample4 = texture2DRect(tex0, texcoord3).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample2, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample1, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample4, vec3(0.256788, 0.504125, 0.097905)) + 0.062745);
    }
]

lazyshader 0 "movieu" [
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy + vec2(-3.0, 0.0);
        texcoord1 = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        texcoord2 = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
        texcoord3 = gl_MultiTexCoord0.xy + vec2( 3.0, 0.0);
    }
] [
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, texcoord0).rgb;
        vec3 sample2 = texture2DRect(tex0, texcoord1).rgb;
        vec3 sample3 = texture2DRect(tex0, texcoord2).rgb;
        vec3 sample4 = texture2DRect(tex0, texcoord3).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample2, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample1, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample4, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961);
    }
]

lazyshader 0 "moviev" [
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy + vec2(-3.0, 0.0);
        texcoord1 = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        texcoord2 = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
        texcoord3 = gl_MultiTexCoord0.xy + vec2( 3.0, 0.0);
    }
] [
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, texcoord0).rgb;
        vec3 sample2 = texture2DRect(tex0, texcoord1).rgb;
        vec3 sample3 = texture2DRect(tex0, texcoord2).rgb;
        vec3 sample4 = texture2DRect(tex0, texcoord3).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample2, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample1, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample4, vec3(0.439216, -0.367788, -0.071427)) + 0.501961);
    }
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

watershader = [
    specular = $arg2
    rgbfog = $arg3
    distort = $arg4
    combine = $arg5
    lazyshader 0 $arg1 [
        uniform mat4 camprojmatrix;
        uniform vec3 camera;
        uniform mat4 watermatrix;
        uniform float waterheight;
        uniform float millis;
        @(if $specular [result [uniform vec3 lightpos; varying vec3 lightdir;]])
        varying vec3 camdir, color;
        varying vec4 texcoord0;
        varying vec2 texcoord1, texcoord2;
        void main(void)
        {
            gl_Position = camprojmatrix * gl_Vertex;
            color = gl_Color.rgb;
            texcoord0 = watermatrix * gl_Vertex;
            @(if (>= (strstr $arg1 "underwater") 0) [result [
                texcoord0.z = waterheight - gl_Vertex.z;
            ]] [result [
                texcoord0.z = gl_Vertex.z - waterheight;
            ]])
            vec2 tc = gl_MultiTexCoord0.xy * 0.1;
            texcoord1 = tc + millis*0.04;
            texcoord2 = tc - millis*0.02;
            camdir = camera - gl_Vertex.xyz;
            @(if $specular [result [
                lightdir = lightpos - gl_Vertex.xyz;
            ]])
        }
    ] [
        @(if $rgbfog [result [
            #pragma CUBE2_fog
        ]] [result [
            #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
        ]])
        uniform vec2 depth;
        @(if $specular [result [uniform vec3 lightcolor; uniform float lightradius; varying vec3 lightdir;]])
        varying vec3 camdir, color;
        varying vec4 texcoord0;
        varying vec2 texcoord1, texcoord2;
        @(if (>= (strstr $arg1 "env") 0) [result [
            uniform samplerCube tex0;
        ]] [result [
            uniform sampler2D tex0;
        ]]) 
        uniform sampler2D tex1, tex2, tex3;
        void main(void)
        {
            vec3 camvec = normalize(camdir);
            @(if $specular [result [
                vec3 lightvec = normalize(lightdir);
                vec3 halfangle = normalize(camvec + lightvec);
            ]])
                
            vec2 dudv = texture2D(tex2, texcoord1).xy*2.0 - 1.0;
        
            @distort
            
            @(if $specular [result [
                float spec = pow(clamp(dot(halfangle, bump), 0.0, 1.0), 96.0);
                vec3 light = lightcolor * (1.0 - clamp(length(lightdir)/lightradius, 0.0, 1.0));
            ]])

            @combine
        }
    ]
]

watershader "waterglare" 1 1 [
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
    gl_FragColor = vec4(light*spec*spec*32.0, 0.0);
]
lazyshader 0 "waterglarefast" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
    }
] [
    void main(void)
    {
        gl_FragColor = vec4(0.0);
    }
]
fastshader waterglare waterglarefast 2
altshader waterglare waterglarefast

lazyshader 0 "underwater" [
    uniform mat4 camprojmatrix;
    varying vec3 color;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color.rgb;
    }
] [
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
    uniform vec2 depth;
    varying vec3 color;
    void main(void)
    {    
        gl_FragColor.rgb = 0.8*depth.x*color;
        gl_FragColor.a = 0.5*depth.y; 
    }
]

watershader "underwaterrefract" 0 1 [
    dudv = texture2D(tex2, texcoord2 + 0.025*dudv).xy*2.0 - 1.0;

    gl_FragColor = texture2D(tex3, texcoord0.xy/texcoord0.w + 0.01*dudv);
] []
watershader "underwaterrefractfast" 0 1 [
    gl_FragColor = texture2DProj(tex3, texcoord0 + vec4(0.4*dudv, 0.0, 0.0));
] []
fastshader underwaterrefract underwaterrefractfast 2
altshader underwaterrefract underwaterrefractfast

watershader "underwaterfade" 0 1 [
    dudv = texture2D(tex2, texcoord2 + 0.025*dudv).xy*2.0 - 1.0;

    vec2 projtc = texcoord0.xy/texcoord0.w;
    float fade = texcoord0.z + 4.0*texture2D(tex3, projtc).a;
    gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);
    gl_FragColor.rgb = texture2D(tex3, projtc + 0.01*dudv).rgb; 
] []
watershader "underwaterfadefast" 0 1 [
    gl_FragColor.rgb = texture2DProj(tex3, texcoord0 + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    gl_FragColor.a = texcoord0.z + 4.0*texture2DProj(tex3, texcoord0).a;
] []
fastshader underwaterfade underwaterfadefast 2
altshader underwaterfade underwaterfadefast

watershader "water" 1 0 [
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = color*depth.x*mix(0.6, 1.0, invfresnel*0.5+0.5) + spec*light;
    gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterfast" 0 0 [
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [    
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = color*depth.x*mix(0.6, 1.0, invfresnel*0.5+0.5);
    gl_FragColor.a = invfresnel*depth.y;
]
fastshader water waterfast 1
altshader water waterfast

watershader "waterreflect" 1 0 [
    vec3 reflect = texture2DProj(tex0, texcoord0 + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5) + spec*light;
    gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterreflectfast" 0 0 [
    vec3 reflect = texture2DProj(tex0, texcoord0 + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5);
    gl_FragColor.a = invfresnel*depth.y;
]
fastshader waterreflect waterreflectfast 2
altshader waterreflect waterreflectfast

watershader "waterrefract" 1 1 [
    vec2 dtc = texcoord2 + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec2 rtc = texcoord0.xy/texcoord0.w + 0.01*dudv;
    vec3 reflect = texture2D(tex0, rtc).rgb;
    vec3 refract = texture2D(tex3, rtc).rgb;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5) + spec*light, 0.0);
]
watershader "waterrefractfast" 0 1 [
    vec4 rtc = texcoord0 + vec4(0.4*dudv, 0.0, 0.0);
    vec3 reflect = texture2DProj(tex0, rtc).rgb;
    vec3 refract = texture2DProj(tex3, rtc).rgb;
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5), 0.0);
]
fastshader waterrefract waterrefractfast 2
altshader waterrefract waterrefractfast

watershader "waterfade" 1 1 [
    vec2 dtc = texcoord2 + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec2 projtc = texcoord0.xy/texcoord0.w;
    vec2 rtc = projtc + 0.01*dudv;
    vec3 reflect = texture2D(tex0, rtc).rgb;
    vec3 refract = texture2D(tex3, rtc).rgb;
    float fade = texcoord0.z + 4.0*texture2D(tex3, projtc).a;
    gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5) + spec*light;
]   
watershader "waterfadefast" 0 1 [
    vec4 rtc = texcoord0 + vec4(0.4*dudv, 0.0, 0.0);
    vec3 reflect = texture2DProj(tex0, rtc).rgb;
    vec3 refract = texture2DProj(tex3, rtc).rgb;
    gl_FragColor.a = texcoord0.z + 4.0*texture2DProj(tex3, texcoord0).a;
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [ 
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5);
]
fastshader waterfade waterfadefast 2
altshader waterfade waterrefract

watershader "waterenv" 1 0 [
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5) + spec*light;
    gl_FragColor.a = invfresnel*depth.y; 
]
watershader "waterenvfast" 0 0 [
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5);
    gl_FragColor.a = invfresnel*depth.y; 
]
fastshader waterenv waterenvfast 2
altshader waterenv waterenvfast

watershader "waterenvrefract" 1 1 [
    vec2 dtc = texcoord2 + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec3 refract = texture2D(tex3, texcoord0.xy/texcoord0.w + 0.01*dudv).rgb;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5) + spec*light, 0.0);
]
watershader "waterenvrefractfast" 0 1 [
    vec3 refract = texture2DProj(tex3, texcoord0 + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5), 0.0);
]
fastshader waterenvrefract waterenvrefractfast 2
altshader waterenvrefract waterenvrefractfast

watershader "waterenvfade" 1 1 [
    vec2 dtc = texcoord2 + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec2 projtc = texcoord0.xy/texcoord0.w;
    vec3 refract = texture2D(tex3, projtc + 0.01*dudv).rgb;
    float fade = texcoord0.z + 4.0*texture2D(tex3, projtc).a;
    gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);

    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5) + spec*light;
]
watershader "waterenvfadefast" 0 1 [
    vec3 refract = texture2DProj(tex3, texcoord0 + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    gl_FragColor.a = texcoord0.z + 4.0*texture2DProj(tex3, texcoord0).a;
    vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5);
]
fastshader waterenvfade waterenvfadefast 2
altshader waterenvfade waterenvrefract

causticshader = [
    lazyshader 0 $arg1 [
        uniform mat4 camprojmatrix;
        uniform vec3 texgenS, texgenT;
        varying vec2 texcoord0;
        void main(void)
        {
            gl_Position = camprojmatrix * gl_Vertex;
            texcoord0 = vec2(dot(texgenS, gl_Vertex.xyz), dot(texgenT, gl_Vertex.xyz)); 
        }
    ] [
        #pragma CUBE2_fog vec3(0.0, 0.0, 0.0)
        uniform vec3 frameoffset;
        varying vec2 texcoord0;
        uniform sampler2D tex0, tex1;
        void main(void)
        {
            @arg2
        }
    ]
]
causticshader caustic [
    gl_FragColor = frameoffset.x*texture2D(tex0, texcoord0) + frameoffset.y*texture2D(tex1, texcoord0);
]
causticshader causticfast [
    gl_FragColor = frameoffset.z*texture2D(tex0, texcoord0);
]
fastshader caustic causticfast 2

lazyshader 0 "lava" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_FragColor = color * texture2D(tex0, texcoord0) * 2.0; 
    }
]

lazyshader 0 "lavaglare" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color*2.0 - 1.0;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        vec4 glow = texture2D(tex0, texcoord0) * color;
        float k = max(glow.r, max(glow.g, glow.b));
        gl_FragColor = glow*k*k*32.0;
    }
]

lazyshader 0 "waterfallrefract" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    uniform mat4 watermatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    varying vec4 texcoord1;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
        texcoord1 = watermatrix * gl_Vertex; 
    }
] [
    uniform vec2 dudvoffset;
    uniform sampler2D tex0, tex2, tex4;
    varying vec4 color;
    varying vec2 texcoord0;
    varying vec4 texcoord1;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        vec2 dudv = texture2D(tex2, texcoord0 + 0.2*diffuse.xy + dudvoffset).xy; 
        vec4 refract = texture2DProj(tex4, texcoord1 + vec4(4.0*dudv, 0.0, 0.0));
        gl_FragColor = mix(refract, color, diffuse);
    }
]

lazyshader 0 "waterfallenvrefract" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    uniform mat4 watermatrix;
    uniform vec3 camera;
    varying vec4 color;
    varying vec2 texcoord0;
    varying vec4 texcoord1;
    varying vec3 camdir;
    varying mat3 world; 
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
        texcoord1 = watermatrix * gl_Vertex;
        camdir = camera - gl_Vertex.xyz;
        vec3 absnorm = abs(gl_Normal);
        world = mat3(absnorm.yzx, -absnorm.zxy, gl_Normal);
    }
] [
    uniform vec2 dudvoffset;
    uniform sampler2D tex0, tex1, tex2, tex4;
    uniform samplerCube tex3;
    varying vec4 color;
    varying vec2 texcoord0;
    varying vec4 texcoord1;
    varying vec3 camdir;
    varying mat3 world; 
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        vec2 dudv = texture2D(tex2, texcoord0 + 0.2*diffuse.xy + dudvoffset).xy; 
        vec3 normal = world * (texture2D(tex1, texcoord0 + 0.1*dudv).rgb*2.0 - 1.0);
        vec4 refract = texture2DProj(tex4, texcoord1 + vec4(4.0*dudv, 0.0, 0.0));
        vec3 camvec = normalize(camdir);
        float invfresnel = dot(normal, camvec);
        vec4 reflect = textureCube(tex3, 2.0*invfresnel*normal - camvec);
        gl_FragColor = mix(mix(reflect, refract, 1.0 - 0.4*step(0.0, invfresnel)), color, diffuse); 
    }
]
altshader waterfallenvrefract waterfallrefract

lazyshader 0 "waterfallenv" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    uniform vec3 camera;
    varying vec2 texcoord0;
    varying vec3 color, camdir;
    varying mat3 world; 
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color.rgb;
        texcoord0 = gl_MultiTexCoord0.xy;
        camdir = camera - gl_Vertex.xyz;
        vec3 absnorm = abs(gl_Normal);
        world = mat3(absnorm.yzx, -absnorm.zxy, gl_Normal);
    }
] [
    uniform vec2 dudvoffset;
    uniform sampler2D tex0, tex1, tex2;
    uniform samplerCube tex3;
    varying vec2 texcoord0;
    varying vec3 color, camdir;
    varying mat3 world; 
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        vec2 dudv = texture2D(tex2, texcoord0 + 0.2*diffuse.xy + dudvoffset).xy; 
        vec3 normal = world * (texture2D(tex1, texcoord0 + 0.1*dudv).rgb*2.0 - 1.0);
        vec3 camvec = normalize(camdir);
        vec4 reflect = textureCube(tex3, 2.0*dot(normal, camvec)*normal - camvec);
        gl_FragColor.rgb = mix(reflect.rgb, color, diffuse.rgb);
        gl_FragColor.a = 0.25 + 0.75*diffuse.r;    
    }
]

lazyshader 0 "glass" [
    uniform mat4 camprojmatrix;
    uniform vec3 camera;
    varying vec3 color, rvec, camdir, normal;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color.rgb;
        rvec = gl_MultiTexCoord0.xyz;
        camdir = camera - gl_Vertex.xyz;
        normal = gl_Normal;
    }
] [ 
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
    uniform samplerCube tex0;
    varying vec3 color, rvec, camdir, normal;
    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 reflect = textureCube(tex0, rvec).rgb;
   
        float invfresnel = max(dot(camvec, normal), 0.70); 
        gl_FragColor.rgb = mix(reflect, color*0.05, invfresnel);
        gl_FragColor.a = invfresnel * 0.95;
    }
]
lazyshader 0 "glassfast" [
    uniform mat4 camprojmatrix;
    varying vec3 color, rvec;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color.rgb;
        rvec = gl_MultiTexCoord0.xyz;
    }
] [ 
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
    uniform samplerCube tex0;
    varying vec3 color, rvec;
    void main(void)
    {
        vec3 reflect = textureCube(tex0, rvec).rgb;
        const float invfresnel = 0.75;
        gl_FragColor.rgb = mix(reflect, color*0.05, invfresnel);
        gl_FragColor.a = invfresnel * 0.95; 
    }
]
fastshader glass glassfast 2
altshader glass glassfast

lazyshader 0 "grass" [
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0, texcoord1;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
        texcoord1 = gl_MultiTexCoord1.xy;
    }
] [
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 0.0)
    varying vec4 color;
    varying vec2 texcoord0, texcoord1;
    uniform sampler2D tex0, tex1;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        diffuse.rgb *= 2.0;
        vec4 lm = texture2D(tex1, texcoord1) * color;
        lm.rgb *= lm.a;
        gl_FragColor = diffuse * lm;
    }
]

shader 0 "overbrightdecal" [
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    #pragma CUBE2_fog vec3(0.0, 0.0, 0.0)
    varying vec4 color;
    varying vec2 texcoord0;
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        gl_FragColor = mix(color, diffuse, color.a);
    }
]

shader 0 "saturatedecal" [
    #pragma CUBE2_fog
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    varying vec4 color;
    varying vec2 texcoord0;
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        diffuse.rgb *= 2.0;
        gl_FragColor = diffuse * color;
    }
]

shader 0 "skybox" [
    uniform mat4 skymatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = skymatrix * gl_Vertex;
        texcoord0 = gl_MultiTexCoord0.xy;
        color = gl_Color;
    }
] [
    varying vec2 texcoord0;
    varying vec4 color;
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = color * texture2D(tex0, texcoord0);
    }
]

shader 0 "skyboxglare" [
    uniform mat4 skymatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = skymatrix * gl_Vertex;
        color = gl_Color;
        texcoord0 = gl_MultiTexCoord0.xy;
    }
] [
    varying vec4 color;
    varying vec2 texcoord0;
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 glare = texture2D(tex0, texcoord0) * color;
        gl_FragColor.rgb = vec3(dot(glare.rgb, vec3(10.56, 10.88, 10.56)) - 30.4);
        gl_FragColor.a = glare.a;
    }
]

shader 0 "skyfog" [
    uniform mat4 skymatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = skymatrix * gl_Vertex;
        color = gl_Color;
    }
] [
    varying vec4 color;
    void main(void)
    {
        gl_FragColor = color;
    }
]

