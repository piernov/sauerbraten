// console language standard library

// creates a macro whose body is a format string
// i.e. macro greet [ say Hi, %1! ]
macro = [
    $arg1 = (concat [format [@@arg2]] (loopconcat i $numargs [concatword " $arg" (+ $i 1)]))
]

// binds a key so that it will toggle a variable
// i.e. bindvar 9 thirdperson
bindvar = [
  bind $arg1 [@arg2 (= $@arg2 0); if (= $@arg2 0) [echo @@arg2 OFF] [ echo @@arg2 ON]]
]
bindvarquiet = [
  bind $arg1 [@arg2 (= $@arg2 0)]
]

// same as above, but only binds for edit mode
editbindvar = [
  editbind $arg1 [@arg2 (= $@arg2 0); if (= $@arg2 0) [echo @@arg2 OFF] [ echo @@arg2 ON]]
]
editbindvarquiet = [
  editbind $arg1 [@arg2 (= $@arg2 0)]
]

// binds a key so that it will set a modifier while held down
bindmod = [
  bind $arg1 [@arg2 1; onrelease [@@arg2 0]]
]

// same as above, but only binds for edit mode
editbindmod = [
  editbind $arg1 [@arg2 1; onrelease [@@arg2 0]]
]

quine = [ echo (format "quine = [%1]" $quine) ]

loadsky = [
    skybox $arg1
    if (> $numargs 1) [
        spinsky $arg2
    ] [
        if (!=f $spinsky 0) [spinsky 0]
    ]
]

mapmsg = [ maptitle $arg1 ]

///////////////////////////////////////////
// Color Library by Redon
clampf = [
  minf (maxf $arg1 $arg2) $arg3
]

fmod = [
  modf (+f (modf $arg1 $arg2) $arg2) $arg2
]

// int2rgb <int>
int2rgb = [
  local r g b
  r = (& (>> $arg1 16) 0xFF)
  g = (& (>> $arg1  8) 0xFF)
  b = (& (>> $arg1  0) 0xFF)
  result [@r @g @b]
]

// rgb2int <[red green blue]>
rgb2int = [
  local r g b
  r = (& (at $arg1 0) 0xFF)
  g = (& (at $arg1 1) 0xFF)
  b = (& (at $arg1 2) 0xFF)
  + (+ (<< $r 16) (<< $g 8)) $b
]

// hsv2rgb <[hue saturation value]>    0-360 0-1 0-1
hsv2rgb = [
  local h s v
  h = (fmod (at $arg1 0) 360)
  s = (clampf (at $arg1 1) 0 1)
  v = (clampf (at $arg1 2) 0 1)

  local F G
  F = [
    fmod (+f (divf $h 60) $arg1) 6
  ]
  G = [
    *f $v (-f 1 (*f $s (clampf (minf (-f 4 (F $arg1)) (F $arg1)) 0 1)))
  ]

  looplistconcat i [5 3 1] [G $i]
]

// rgb2hsv <[red green blue]>    0-1
rgb2hsv = [
  local r g b
  r = (at $arg1 0)
  g = (at $arg1 1)
  b = (at $arg1 2)

  local cmax cmin delta
  cmax = (maxf $r (maxf $g $b))
  cmin = (minf $r (minf $g $b))
  delta = (-f $cmax $cmin)

  local h s v
  h = (*f 60 (cond [=f $cmax $r] [
    fmod (divf (-f $g $b) $delta) 6
  ] [=f $cmax $g] [
    +f (divf (-f $b $r) $delta) 2
  ] [ 1 ] [
    +f (divf (-f $r $g) $delta) 4
  ]))
  s = (? $cmax (divf $delta $cmax) 0)
  v = $cmax

  result [@h @s @v]
]
